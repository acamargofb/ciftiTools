file.exists(sphereR_original_fname)
#' Resample CIFTI data
#'
#' @description Performs spatial resampling of CIfTI data on the cortical surface
#'
#' @param c_original_fnames File paths of CIFTI file components in original resolution. Should be a named character vector with values
#'  as the file names, and names as the file label: each name should be one of "cortexL", "cortexR", "subcortVol", "subcortLab",
#'  "cortexL_ROI", "cortexR_ROI", or "subcort_ROI". Alternatively, this can be the file name of the original CIfTI that was separated
#'  into files named by default using ciftiTools::cifti_separate_default_suffix . All existing files in \code{c_original_fnames} will be resampled.
#' @param c_target_fnames File paths of CIFTI file components in target resolution to make. Should be a named character vector with values
#'  as the file names, and names as the file label: each name should be one of "cortexL", "cortexR", "subcortVol", "subcortLab",
#'  "cortexL_ROI", "cortexR_ROI", or "subcort_ROI". Alternatively, this can be the file name of the original CIfTI that was separated
#'  into files named by default using ciftiTools::cifti_separate_default_suffix .
#' @param surfL_original_fname,surfR_original_fname (Optional) File path, or vector of multiple file paths, of GIFTI surface geometry file
#'  representing left/right cortex to resample.
#' @param surfL_target_fname,surfR_target_fname (Optional) File path, or vector of multiple file paths, of GIFTI surface geometry file
#'  representing left/right cortex to save the resampled data as. Each should correspond to \code{surf[L/R]_original_fname}.
#' @param res_target Target resolution (number of cortical surface vertices per hemisphere)
#' @param sphereL_original_fname,sphereR_original_fname File path of [left/right]-hemisphere spherical GIFTI files in original resolution
#'  (compatible with cifti_orig) .
#' @param sphereL_target_fname,sphereR_target_fname File path of [left/right]-hemisphere spherical GIFTI files in targetinal resolution
#'  (compatible with cifti_Target) . NULL (default) will be named as "Resampled_[res_target]_[basename(sphere[L/R]_original_fname)]"
#' @param sphere_target_keep Should helper files be deleted at the end of this function call, if they were created? Default is FALSE.
#' @param sphere_target_overwrite Logical indicating whether sphere[L/R]_target_fname should be overwritten if it already exists. Default is TRUE.
#' @param overwrite Logical indicating whether each target file should be overwritten if it already exists.
#' @param read_dir If the file names of \code{c_original_fnames}, \code{surfL_original_fname}, or \code{surfR_original_fname} are relative, this is the
#'  directory to look for them in. If NULL (default), use the current working directory. \code{read_dir} will not affect files specified
#   with absolute paths.
#' @param write_dir If the file names of \code{c_target_fnames} or surf[L/R]_original_fname are relative, this is the directory to look for them in.
#'  Defaults to the current working directory.
#' @param sphere_target_dir If \code{sphere_target_keep} and the file names of \code{c_original_fnames} are relative, this is the directory to
#'  write and look for them in. The default is "./helper_files_resampling".
#' @param wb_path (Optional) Path to Connectome Workbench folder. If not provided, should be set with
#'  \code{ciftiTools.setOption('wb_path', 'path/to/workbench')}.
#'
#' @return Logical indicating whether resampled CIFTI file was created.
#' @export
#'
#' @details Performs resampling of CIFTI files using Connectome Workbench tools.  Several helper files must be created:
#'
#' Step 1: Generate spheres in the target resolution (if not already existing and provided)
#' Step 2: Use -metric-resample to resample surface/cortex files into target resolution
#' Step 3: Use -surface-resample to resample the gifti files (if provided) into target resolution
cifti_resample_separate <- function(c_original_fnames, c_target_fnames=NULL,
surfL_original_fname=NULL, surfR_original_fname=NULL, surfL_target_fname=NULL, surfR_target_fname=NULL,
res_target,
sphereL_original_fname, sphereR_original_fname,
sphereL_target_fname=NULL, sphereR_target_fname=NULL,
sphere_target_keep=FALSE, sphere_target_overwrite=TRUE,
overwrite=TRUE, read_dir=NULL, write_dir=NULL, sphere_target_dir=NULL, wb_path=NULL){
wb_cmd <- get_wb_cmd_path(wb_path)
# Check Arguments
## c_original_fnames
read_dir <- check_dir(read_dir)
possible_file_labels <- c("cortexL", "cortexR", "subcortVol", "cortexL_ROI", "cortexR_ROI", "subcort_ROI")
if(length(c_original_fnames)==1 & grepl("\\.d.*.nii$", c_original_fnames)){ # .d*.nii or .d*.nii where * is tseries or scalar
c_original_fnames <- as.list(possible_file_labels)
names(c_original_fnames) <- c_original_fnames
c_original_fnames <- sapply(c_original_fnames, cifti_separate_default_suffix)
c_original_fnames <- make_abs_path(c_original_fnames, read_dir)
if(sum(file.exists(c_original_fnames)) < 1){
stop(paste("The `c_original_fnames` argument is", c_original_fnames, ", a NIfTI file name.",
"However, no separated files with default names exist. The files that were looked for are:\n\n",
paste(as.character(c_original_fnames), collapse="\n")))
}
c_original_fnames <- c_original_fnames[file.exists(c_original_fnames)]
} else {
names(c_original_fnames) <- match.arg(names(c_original_fnames), possible_file_labels, several.ok=TRUE)
stopifnot(length(unique(names(c_original_fnames))) == length(c_original_fnames))
c_original_fnames <- lapply(c_original_fnames, make_abs_path, read_dir)
if(!all(sapply(c_original_fnames, file.exists))){
stop(do.call(paste, c("This file(s) to resample does not exist:",
as.character(c_original_fnames)[!sapply(c_original_fnames, file.exists)])))
stop(paste("This file(s) to resample does not exist:\n\n",
paste(as.character(c_original_fnames)[!sapply(c_original_fnames, file.exists)], collapse="\n")))
}
}
## c_target_fnames
original_to_target_fname <- function(original_fname, res_target){
bname <- basename(original_fname)
paste("resampled", res_target, bname, sep="_")
}
write_dir <- check_dir(write_dir)
if(is.null(c_target_fnames)){
c_target_fnames <- lapply(c_original_fnames, original_to_target_fname, res_target)
} else if(length(c_target_fnames)==1 & grepl("\\.d.*.nii$", c_target_fnames)){ # .d*.nii or .d*.nii where * is tseries or scalar
c_target_fnames <- lapply(c_original_fnames, original_to_target_fname, res_target)
} else {
names(c_target_fnames) <- match.arg(names(c_target_fnames), possible_file_labels, several.ok=TRUE)
stopifnot(length(unique(names(c_target_fnames))) == length(c_target_fnames))
stopifnot(length(c_target_fnames) > 0)
}
for(i in 1:length(c_original_fnames)){
lab_i <- names(c_original_fnames)[i]
if(identical(c_target_fnames[[lab_i]], NULL)){
c_target_fnames[[lab_i]] <- original_to_target_fname(c_original_fnames[[lab_i]], res_target)
}
c_target_fnames[[lab_i]] <- make_abs_path(c_target_fnames[[lab_i]], write_dir)
}
if(length(c_target_fnames) > length(c_original_fnames)){
missing_original <- names(c_target_fnames)[!(names(c_target_fnames) %in% names(c_original_fnames))]
warning(paste("Ignoring these resampling targets because their original files were not provided:", missing_original))
}
c_target_fnames <- c_target_fnames[names(c_original_fnames)]
## surfL
if(!is.null(surfL_original_fname)){
surfL_original_fname <- make_abs_path(surfL_original_fname, read_dir)
if(!all(file.exists(surfL_original_fname))){
stop(paste(c("This file(s) to resample does not exist:", surfL_original_fname[!file.exists(surfL_original_fname)]), collapse=" "))
}
if(is.null(surfL_target_fname)){
surfL_target_fname <- original_to_target_fname(surfL_original_fname, res_target)
}
surfL_target_fname <- make_abs_path(surfL_target_fname, write_dir)
stopifnot(length(surfL_original_fname) == length(surfL_target_fname))
} else { surfL_target_fname <- "" }
## surfR
if(!is.null(surfR_original_fname)){
surfR_original_fname <- make_abs_path(surfR_original_fname, read_dir)
if(!all(file.exists(surfR_original_fname))){
stop(paste(c("This file(s) to resample does not exist:", surfR_original_fname[!file.exists(surfR_original_fname)]), collapse=" "))
}
if(is.null(surfR_target_fname)){
surfR_target_fname <- original_to_target_fname(surfR_original_fname, res_target)
}
surfR_target_fname <- make_abs_path(surfR_target_fname, write_dir)
stopifnot(length(surfR_original_fname) == length(surfR_target_fname))
} else { surfR_target_fname <- "" }
# other args
sphere_target_dir <- check_dir(sphere_target_dir, "helper_files_resampling", make=TRUE)
sphereL_original_fname <- make_abs_path(sphereL_original_fname)
sphereR_original_fname <- make_abs_path(sphereR_original_fname)
stopifnot(all(file.exists(c(sphereL_original_fname, sphereR_original_fname))))
if(is.null(sphereL_target_fname)){ sphereL_target_fname <- original_to_target_fname(sphereL_original_fname, res_target) }
if(is.null(sphereR_target_fname)){ sphereR_target_fname <- original_to_target_fname(sphereR_original_fname, res_target) }
sphereL_target_fname <- make_abs_path(sphereL_target_fname, write_dir)
sphereR_target_fname <- make_abs_path(sphereR_target_fname, write_dir)
stopifnot(is.logical(sphere_target_keep))
stopifnot(is.logical(sphere_target_overwrite))
# Collect the absolute paths to each file in a data.frame to return later. Also record whether each existed before the
# workbook command.
resamp_files <- data.frame(
label = c(names(c_target_fnames),
paste0("surfL_", 1:length(surfL_target_fname)),
paste0("surfR_", 1:length(surfR_target_fname))),
fname = c(as.character(c_target_fnames),
surfL_target_fname,
surfR_target_fname),
stringsAsFactors=FALSE
)
resamp_files <- resamp_files[resamp_files$fname != "",]
resamp_files$existed <- file.exists(resamp_files$fname)
# Step 1: Generate spheres in the target resolution (if not already existing and provided)
sphere_target_exists <- file.exists(sphereL_target_fname, sphereR_target_fname)
if(sum(sphere_target_exists) == 1){ warning("One sphere target file exists but not the other. Overwriting the existing file.") }
if(sphere_target_overwrite | !all(sphere_target_exists)){
if(verbose) cat("\nCreating spherical surfaces in target resolution... \n")
make_helper_spheres(sphereL_target_fname, sphereR_target_fname, res_target, sphere_target_dir, wb_cmd)
}
# Step 2: Use -metric-resample to resample surface/cortex files into target resolution
resample_individual_kwargs_common <- list(res_target=res_target,
overwrite=overwrite, read_dir=read_dir, write_dir=write_dir, sphere_target_dir=sphere_target_dir, wb_path=wb_path)
for(lab in c("cortexL", "cortexR")){
if(lab %in% names(c_original_fnames)){
if(overwrite | !resamp_files$existed[resamp_files$label==lab]){
is_left <- lab == "cortexL"
additional_kwargs <- list(
original_fname=c_original_fnames[[lab]], target_fname=c_target_fnames[[lab]], file_type="metric",
sphere_original_fname=ifelse(is_left, sphereL_original_fname, sphereR_original_fname),
sphere_target_fname=ifelse(is_left, sphereL_target_fname, sphereR_target_fname) )
roi_lab <- paste0(gsub("subcortVol", "subcort", lab), "_ROI")
if(roi_lab %in% names(c_original_fnames)){
additional_kwargs <- c(additional_kwargs,
list(original_ROI_fname=c_original_fnames[[roi_lab]], target_ROI_fname=c_target_fnames[[roi_lab]]))
}
do.call(resample_individual, c(resample_individual_kwargs_common, additional_kwargs))
}
}
}
# Step 3: Use -surface-resample to resample surface/cortex files into target resolution
for(i in 1:length(surfL_original_fname)){
if(overwrite | !resamp_files$existed[resamp_files$label==paste0("surfL_", i)]){
additional_kwargs <- list(
original_fname=surfL_original_fname[i], target_fname=surfL_target_fname[i], file_type="surface",
sphere_original_fname=sphereL_original_fname, sphere_target_fname=sphereL_target_fname)
do.call(resample_individual, c(resample_individual_kwargs_common, additional_kwargs))
}
}
for(i in 1:length(surfR_original_fname)){
if(overwrite | !resamp_files$existed[resamp_files$label==paste0("surfR_", i)]){
additional_kwargs <- list(
original_fname=surfR_original_fname[i], target_fname=surfR_target_fname[i], file_type="surface",
sphere_original_fname=sphereR_original_fname, sphere_target_fname=sphereR_target_fname)
do.call(resample_individual, c(resample_individual_kwargs_common, additional_kwargs))
}
}
invisible(resamp_files)
}
#' Resample an individual file (with its ROI)
#'
#' @description Performs spatial resampling of NIfTI/GIfTI data on the cortical surface
#'
#' @param original_fname The file to resample.
#' @param target_fname Where to save the resampled file.
#' @param original_ROI_fname The name of the ROI file corresponding to \code{original_fname}. Leave as NULL (default) if this
#'  doesn't exist or shouldn't be resampled.
#' @param target_ROI_fname The name of the resampled ROI file. Only applicable if \code{original_ROI_fname} is provided.
#' @param file_type "metric" or "surface", or NULL (default) to infer from \code{original_fname}.
#' @param res_target Target resolution (number of cortical surface vertices per hemisphere)
#' @param sphere_original_fname File path of [left/right]-hemisphere spherical GIFTI files in original resolution
#'  The hemisphere side should match \code{original_fname}.
#' @param sphere_target_fname File path of [left/right]-hemisphere spherical GIFTI files in targetinal resolution
#'  The hemisphere side should match \code{target_fname}. See \code{make_helper_spheres}.
#' @param overwrite Logical indicating whether original_fname should be overwritten if it already exists.
#' @param read_dir If the file names of \code{original_fname} and \code{original_ROI_fname} are relative, this is the directory to
#'  look for them in. If NULL (default), use the current working directory. \code{read_dir} will not affect files specified with absolute paths.
#' @param write_dir If the file names of \code{target_fname} and \code{target_ROI_fname} are relative, this is the directory to
#'  look for them in. If NULL (default), use the current working directory. \code{write_dir} will not affect files specified with absolute paths.
#' @param sphere_target_dir If \code{sphere_target_keep} and the file names of \code{c_original_fnames} are relative, this is the directory to
#'  write and look for them in. The default is "./helper_files_resampling".
#' @param wb_path (Optional) Path to Connectome Workbench folder. If not provided, should be set with
#'  \code{ciftiTools.setOption('wb_path', 'path/to/workbench')}.
#'
#' @return Logical indicating whether resampled file was created.
#' @export
#'
resample_individual <- function(original_fname, target_fname,
original_ROI_fname=NULL, target_ROI_fname=NULL, file_type=NULL, res_target,
sphere_original_fname, sphere_target_fname, overwrite=TRUE,
read_dir=NULL, write_dir=NULL, sphere_target_dir=NULL, wb_path=NULL){
wb_cmd <- get_wb_cmd_path(wb_path)
# Check arguments.
read_dir <- check_dir(read_dir)
original_fname <- make_abs_path(original_fname, read_dir)
stopifnot(file.exists(original_fname))
do_ROI <- !is.null(original_ROI_fname)
if(do_ROI){
original_ROI_fname <- make_abs_path(original_ROI_fname, read_dir)
stopifnot(file.exists(original_ROI_fname))
}
write_dir <- check_dir(write_dir, make=TRUE)
target_fname <- make_abs_path(target_fname, write_dir)
if(do_ROI){
target_ROI_fname <- make_abs_path(target_ROI_fname, read_dir)
stopifnot(file.exists(target_ROI_fname))
}
if(is.null(file_type)){
if(grepl("func.gii", original_fname, fixed=TRUE)){ file_type <- "metric" }
else if(grepl("surf.gii", original_fname, fixed=TRUE)){ file_type <- "surface" }
else{ stop(paste("Could not infer file type of ", original_fname, ". Please set the file_type argument.")) }
}
file_type <- match.arg(file_type, c("metric", "surface"))
stopifnot(is.numeric(res_target))
stopifnot(res_target > 0)
sphere_original_fname <- make_abs_path(sphere_original_fname)
stopifnot(file.exists(sphere_original_fname))
sphere_target_dir <- check_dir(sphere_target_dir, "helper_files_resampling", make=TRUE)
sphere_target_fname <- make_abs_path(sphere_target_fname, sphere_target_dir)
stopifnot(file.exists(sphere_target_fname))
stopifnot(is.logical(overwrite))
if(do_ROI & file_type=="surface"){ stop("do_ROI AND file_type=='surface', but surface files do not use ROI.") }
# Run the command if overwrite==TRUE, or if any desired file does not exist.
run_cmd <- overwrite | all(c(file.exists(target_fname, ifelse(do_ROI, file.exists(target_ROI_fname), TRUE))))
if(!run_cmd){
cmd_code <- NA
} else {
cmd_name <- switch(file_type,
metric="-metric-resample",
surface="-surface-resample"
)
cmd <- paste(wb_cmd, cmd_name, original_fname, sphere_original_fname, sphere_target_fname, "BARYCENTRIC", target_fname)
if(do_ROI){
cmd <- paste(cmd, "-current-roi", original_ROI_fname, "-valid-roi-out", target_ROI_fname)
}
# Run it! Raise an error if it fails.
cmd_code <- system(cmd)
if(cmd_code != 0){
stop(paste0("The Connectome Workbench command failed with code ", cmd_code,
". The command was:\n", cmd))
}
}
invisible(NULL)
}
#' Generates GIFTI sphere surface files
#'
#' @description Generates GIFTI spherical surface files in a target resolution. These are required for resampling CIFTI
#' and GIFTI files.  This function generates a pair of vertex-matched left and right spheres in the target resolution.
#'
#' @param sphereL_fname File path to left-hemisphere spherical GIFTI to be created
#' @param sphereR_fname File path to right-hemisphere spherical GIFTI to be created
#' @param resamp_res Target resolution of spherical GIFTIs to be created (approximate number of vertices per hemisphere)
#' @param write_dir If a file name is relative, what directory should it be saved to? Defaults to the current working directory.
#' @param wb_path (Optional) Path to Connectome Workbench folder. If not provided, should be set with
#'  \code{ciftiTools.setOption('wb_path', 'path/to/workbench')}.
#'
#' @return Logical indicating whether output files exist
#' @export
#'
make_helper_spheres <- function(sphereL_fname, sphereR_fname, resamp_res, write_dir=NULL, wb_path=NULL){
wb_cmd <- get_wb_cmd_path(wb_path)
# Check that write_dir is valid. Use the current working directory if no write_dir is given.
write_dir <- check_dir(write_dir)
sphereL_fname <- make_abs_path(sphereL_fname, write_dir)
sphereR_fname <- make_abs_path(sphereR_fname, write_dir)
system(paste(wb_cmd,'-surface-create-sphere', resamp_res, sphereL_fname, sep=' '))
system(paste(wb_cmd, '-surface-flip-lr', sphereL_fname, sphereR_fname, sep=' '))
system(paste(wb_cmd, '-set-structure', sphereL_fname, 'CORTEX_LEFT', sep=' '))
system(paste(wb_cmd, '-set-structure', sphereR_fname, 'CORTEX_RIGHT', sep=' '))
invisible(file.exists(sphereL_fname) & file.exists(sphereR_fname))
}
resamp_kwargs <- NULL
if(!identical(resamp_res, NULL) & !identical(resamp_res, FALSE)){
if(verbose){ cat("Resampling CIfTI file.\n") }
# Check that the cifti_resample_separate arguments are valid.
resamp_kwargs_allowed <- names(as.list(args(ciftiTools::cifti_resample_separate)))
resamp_kwargs_allowed <- resamp_kwargs_allowed[1:(length(resamp_kwargs_allowed)-1)] # last is empty
if(!is.null(resamp_kwargs)){
names(resamp_kwargs) <- match.arg(names(resamp_kwargs), resamp_kwargs_allowed, several.ok=TRUE)
stopifnot(length(unique(names(resamp_kwargs))) == length(names(resamp_kwargs)))
} else {
resamp_kwargs <- vector(length=0, mode="list")
}
resamp_kwargs[["c_original_fnames"]] <- files_to_read[!grepl("subcort", names(files_to_read))] # labels don't get resampled
resamp_kwargs <- c(resamp_kwargs, list(
surfL_original_fname=surfL_fname, surfR_original_fname=surfR_fname,
res_target=resamp_res,
sphereL_original_fname=resamp_sphereL_fname, sphereR_original_fname=resamp_sphereR_fname
))
# If resamp_keep==FALSE, use a temporary directory
if(!resamp_keep){
if(!is.null(resamp_kwargs$write_dir)){
if(verbose){ cat("Warning: using temporary directory instead of resamp_kwargs$write_dir because resamp_keep is FALSE.\n") }
}
resamp_kwargs$write_dir <- tempdir()
}
# Do cifti_resample_separate
resamp_kwargs[sapply(resamp_kwargs, is.null)] <- NULL
resamp_result <- do.call(cifti_resample_separate, resamp_kwargs)
for(i in 1:nrow(files_to_read)){
if(files_to_read$label[i] %in% resamp_result$label){
files_to_read[i,] <- resamp_result[resamp_result$label == files_to_read$label[i]]
}
}
}
files_to_read
for(i in 1:length(files_to_read)){
if(names(files_to_read)[i] %in% resamp_result$label){
files_to_read[i,] <- resamp_result[resamp_result$label == names(files_to_read)[i]]
}
}
for(i in 1:length(files_to_read)){
if(names(files_to_read)[i] %in% resamp_result$label){
files_to_read[i] <- resamp_result[resamp_result$label == names(files_to_read)[i]]
}
}
files_to_read
resamp_result
for(i in 1:length(files_to_read)){
if(names(files_to_read)[i] %in% resamp_result$label){
files_to_read[i] <- resamp_result$fname[resamp_result$label == names(files_to_read)[i]]
}
}
files_to_read
# Read the CIfTI file from the separated files.
if(verbose){ cat("Reading GIfTI and NIfTI files to form the CIfTI.\n") }
# Note: read_dir will only affect the surfaces because the cifti file paths are absolute.
read_from_separate_kwargs <- c(
files_to_read,
list(surfL_fname=surfL_fname, surfR_fname=surfR_fname, read_dir=NULL, surf_label=surf_label, wb_path=wb_path)
)
read_from_separate_kwargs[sapply(read_from_separate_kwargs, is.null)] <- NULL
result <- do.call(cifti_read_from_separate, read_from_separate_kwargs)
resamp_result
resamp_result$fname[grepl(resamp_result$label, "surfL")]
resamp_result$fname[grepl("surfL", resamp_result)]
resamp_surfL_fname <- resamp_result$fname[grepl("surfL", resamp_result)]
if(length(resamp_surfL_fname) > 0){ surfL_fname <- resamp_surfL_fname }
resamp_surfR_fname <- resamp_result$fname[grepl("surfR", resamp_result)]
if(length(resamp_surfR_fname) > 0){ surfR_fname <- resamp_surfR_fname }
# Read the CIfTI file from the separated files.
if(verbose){ cat("Reading GIfTI and NIfTI files to form the CIfTI.\n") }
# Note: read_dir will only affect the surfaces because the cifti file paths are absolute.
read_from_separate_kwargs <- c(
files_to_read,
list(surfL_fname=surfL_fname, surfR_fname=surfR_fname, read_dir=NULL, surf_label=surf_label, wb_path=wb_path)
)
read_from_separate_kwargs[sapply(read_from_separate_kwargs, is.null)] <- NULL
result <- do.call(cifti_read_from_separate, read_from_separate_kwargs)
surfL_fname
file.exists(surfL_fname)
read_surf <- function(surf_fname){
surf <- readGIfTI(surf_fname)$data
verts <- surf$pointset
faces <- surf$triangle
if(min(faces)==0) faces <- faces + 1 #start vertex indexing at 1 instead of 0
surf <- list(vertices = verts, faces = faces)
class(surf) <- "surface"
return(surf)
}
surfL <- read_surf(surfL_fname)
surfL <- read_surf(surfL_fname)
surfL <- readGIfTI(surfL_fname)
surfL <- readGIfTI(surfL_fname)$data
?surfL_fname
surfL_fname
resamp_result$fname[grepl("surfL", resamp_result)]
resamp_result$fname[grepl("surfL", resamp_result$label)]
resamp_surfL_fname <- resamp_result$fname[grepl("surfL", resamp_result$label)]
if(length(resamp_surfL_fname) > 0){ surfL_fname <- resamp_surfL_fname }
resamp_surfR_fname <- resamp_result$fname[grepl("surfR", resamp_result$label)]
if(length(resamp_surfR_fname) > 0){ surfR_fname <- resamp_surfR_fname }
# Read the CIfTI file from the separated files.
if(verbose){ cat("Reading GIfTI and NIfTI files to form the CIfTI.\n") }
# Note: read_dir will only affect the surfaces because the cifti file paths are absolute.
read_from_separate_kwargs <- c(
files_to_read,
list(surfL_fname=surfL_fname, surfR_fname=surfR_fname, read_dir=NULL, surf_label=surf_label, wb_path=wb_path)
)
read_from_separate_kwargs[sapply(read_from_separate_kwargs, is.null)] <- NULL
result <- do.call(cifti_read_from_separate, read_from_separate_kwargs)
cifti_view(result)
c(NULL, "a")
?cifti_view
?cifti_view_surface
cifti_view <- function(cifti, surface_or_volume=NULL, ...){
if(is.null(surface_or_volume)){
can_do_left <- (!is.null(cifti$CORTEX_LEFT)) & (!is.null(cifti$SURF_LEFT))
can_do_right <- (!is.null(cifti$CORTEX_RIGHT)) & (!is.null(cifti$SURF_RIGHT))
surface_or_volume <- ifelse(can_do_left | can_do_right, "surface", "volume")
}
brainstructures=c("left", "right", "both")
if(surface_or_volume == "surface"){
layout=c("left_2", "right_2", "both_4")[can_do_left + can_do_right*2]
return(cifti_view_surface(cifti, ...))
}
else if(surface_or_volume == "volume"){ return(cifti_view_volume(cifti, ...)) }
else{ stop() }
}
cifti_view(result)
(!is.null(result$CORTEX_LEFT)) & (!is.null(result$SURF_LEFT))
(!is.null(result$CORTEX_RIGHT)) & (!is.null(result$SURF_RIGHT))
cifti_view_surface(result, layout="left_2")
library(ciftiTools)
install.packages("papayar")
roxygen2::roxygenize("ciftiTools")
roxygen2::roxygenize("ciftiTools")
library(ciftiTools)
# setwd("Desktop")
roxygen2::roxygenize("ciftiTools")
ciftiTools.setOption("wb_path", 'workbench/bin_linux64/wb_command')
roxygen2::roxygenize("ciftiTools")
?sd
# setwd("Desktop")
roxygen2::roxygenize("ciftiTools")
ciftiTools.setOption("wb_path", 'workbench/bin_linux64/wb_command')
# setwd("Desktop")
roxygen2::roxygenize("ciftiTools")
ciftiTools.setOption("wb_path", 'workbench/bin_linux64/wb_command')
library(ciftiTools)
cifti_fname <- "Data/cifti_with_surf/rfMRI_REST1_LR_Atlas_MSMAll.dtseries.nii"
surfL_fname = "Data/cifti_with_surf/Q1-Q6_R440.L.inflated.32k_fs_LR.surf.gii"
surfR_fname = "Data/cifti_with_surf/Q1-Q6_R440.R.inflated.32k_fs_LR.surf.gii"
cifti <- cifti_read(cifti_fname,
brainstructures=c("right"),
surfL_fname=c(surfL_fname, surfL_fname),
surfR_fname=c(surfR_fname, surfR_fname), verbose=TRUE)
# setwd("Desktop")
roxygen2::roxygenize("ciftiTools")
ciftiTools.setOption("wb_path", 'workbench/bin_linux64/wb_command')
cifti <- cifti_read(cifti_fname,
brainstructures=c("right"),
surfL_fname=c(surfL_fname, surfL_fname),
surfR_fname=c(surfR_fname, surfR_fname), verbose=TRUE)
# setwd("Desktop")
roxygen2::roxygenize("ciftiTools")
ciftiTools.setOption("wb_path", 'workbench/bin_linux64/wb_command')
cifti <- cifti_read(cifti_fname,
brainstructures=c("right"),
surfL_fname=c(surfL_fname, surfL_fname),
surfR_fname=c(surfR_fname, surfR_fname), verbose=TRUE)
# setwd("Desktop")
roxygen2::roxygenize("ciftiTools")
ciftiTools.setOption("wb_path", 'workbench/bin_linux64/wb_command')
cifti_view_surface(cifti, layout = "right_2", colorbar_position="separate", color_values=c(.5, 1.5))
# setwd("Desktop")
roxygen2::roxygenize("ciftiTools")
ciftiTools.setOption("wb_path", 'workbench/bin_linux64/wb_command')
cifti <- cifti_read(cifti_fname,
brainstructures=c("right"),
resamp_res=1000,
surfL_fname=c(surfL_fname, surfL_fname),
surfR_fname=c(surfR_fname, surfR_fname), verbose=TRUE)
make_abs_path(NULL)
# setwd("Desktop")
roxygen2::roxygenize("ciftiTools")
ciftiTools.setOption("wb_path", 'workbench/bin_linux64/wb_command')
cifti <- cifti_read(cifti_fname,
brainstructures=c("right"),
resamp_res=1000,
#sphereL_fname = , sphereR_fname=,
surfL_fname=c(surfL_fname, surfL_fname),
surfR_fname=c(surfR_fname, surfR_fname), verbose=TRUE)
make_helper_spheres("my_surfL.surf.gii", "my_surfR.surf.gii", 32492)
cifti <- cifti_read(cifti_fname,
brainstructures=c("right"),
resamp_res=1000,
sphereL_fname = "my_surfL.surf.gii", sphereR_fname="my_surfR.surf.gii",
surfL_fname=c(surfL_fname, surfL_fname),
surfR_fname=c(surfR_fname, surfR_fname), verbose=TRUE)
cifti_view_surface(cifti, layout = "right_2", colorbar_position="separate", color_values=c(.5, 1.5))
cifti_view_surface(cifti, layout = "right_2", colorbar_position="embedded", color_values=c(.5, 1.5))
library(ciftiTools)
